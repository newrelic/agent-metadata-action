name: 'Agent Metadata Action'
description: 'Fetches agent configuration metadata to create/update NEGP entities in NR'
inputs:
  newrelic-client-id:
    description: 'NewRelic client ID (pass from secrets)'
    required: true
  newrelic-private-key:
    description: 'NewRelic private key content (pass from secrets)'
    required: true
  agent-type:
    description: 'The type of agent in all lowercase eg. dotnet-agent'
    required: false
    default: ''
  version:
    description: 'Agent version in semver format (ex. 1.2.3 or v1.2.3). The action will prepend "v" if not present for tag checkout.'
    required: false
    default: ''
  fetch-depth:
    description: 'Number of commits to fetch (> 1 may be required for docs flow)'
    required: false
    default: '1'
  cache:
    description: 'Enable Go build cache'
    required: false
    default: 'true'
  apm-control-nr-license-key:
    description: 'New Relic APM license key for instrumentation of this action (optional, pass from secrets)'
    required: false
    default: ''
runs:
  using: 'composite'
  steps:
    - name: Normalize version tag for checkout
      id: version
      shell: bash
      run: |
        VERSION="${{ inputs.version }}"
        if [[ -n "$VERSION" && ! "$VERSION" =~ ^v ]]; then
          echo "ref=v${VERSION}" >> $GITHUB_OUTPUT
        else
          echo "ref=${VERSION}" >> $GITHUB_OUTPUT
        fi

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ steps.version.outputs.ref }} # When ref is empty (as in docs scenario), this will default to checking out the commit that triggered the action
        fetch-depth: ${{ inputs.fetch-depth }}
    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version-file: '${{ github.action_path }}/go.mod'
        cache: ${{ inputs.cache }}
        cache-dependency-path: '${{ github.action_path }}/go.sum'

    - name: Install NewRelic Auth CLI
      shell: bash
      run: |
        # Only skip installation if explicitly testing with a mock CLI
        if [ "$MOCK_NEWRELIC_AUTH_CLI" = "true" ]; then
          if command -v newrelic-auth-cli &> /dev/null; then
            echo "::notice::Using mock newrelic-auth-cli from PATH (testing mode)"
            echo "::debug::Mock CLI at: $(which newrelic-auth-cli)"
            exit 0
          else
            echo "::error::MOCK_NEWRELIC_AUTH_CLI is true but newrelic-auth-cli not found in PATH"
            exit 1
          fi
        fi

        echo "::group::Installing newrelic-auth-cli"
        LATEST_RELEASE=$(curl -s https://api.github.com/repos/newrelic/newrelic-auth-rs/releases/latest | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
        echo "Downloading newrelic-auth-cli version $LATEST_RELEASE"
        curl -L "https://github.com/newrelic/newrelic-auth-rs/releases/download/${LATEST_RELEASE}/newrelic-auth-cli_amd64.tar.gz" -o newrelic-auth-cli.tar.gz
        tar -xzf newrelic-auth-cli.tar.gz
        chmod +x newrelic-auth-cli
        sudo mv newrelic-auth-cli /usr/local/bin/
        echo "::endgroup::"

    - name: Authenticate with NewRelic
      id: newrelic-auth
      shell: bash
      run: |
        set -e  # Exit on any error
        echo "::group::Authenticating with NewRelic"

        # Mask sensitive inputs in logs (must be done before any logging)
        echo "::debug::Masking sensitive credentials..."
        echo "::add-mask::${{ inputs.newrelic-client-id }}"
        echo "::add-mask::${{ inputs.newrelic-private-key }}"

        # Write private key to temporary file
        echo "::debug::Creating temporary file for private key..."
        TEMP_KEY_FILE=$(mktemp)
        echo "::debug::Temporary key file: $TEMP_KEY_FILE"

        echo "${{ inputs.newrelic-private-key }}" | base64 -d > "$TEMP_KEY_FILE"
        chmod 600 "$TEMP_KEY_FILE"
        echo "::debug::Private key written to temp file with secure permissions (600)"

        # Verify file was created
        if [ ! -f "$TEMP_KEY_FILE" ]; then
          echo "::error::Failed to create temporary key file"
          exit 1
        fi
        echo "::debug::Temp file verified (size: $(wc -c < "$TEMP_KEY_FILE") bytes)"

        # Authenticate and capture token
        echo "::debug::Calling newrelic-auth-cli..."
        echo "::debug::Environment: US"
        echo "::debug::Output format: JSON"

        if ! AUTH_OUTPUT=$(newrelic-auth-cli authenticate \
          --client-id "${{ inputs.newrelic-client-id }}" \
          --environment US \
          --output-token-format JSON \
          --private-key-path "$TEMP_KEY_FILE" 2>&1); then
          echo "::error::Authentication failed"
          rm -f "$TEMP_KEY_FILE"
          exit 1
        fi

        echo "::debug::Authentication CLI call completed"

        # Extract token from JSON output
        echo "::debug::Parsing JSON response..."
        if ! TOKEN=$(echo "$AUTH_OUTPUT" | jq -r '.access_token' 2>&1); then
          echo "::error::Failed to parse token from response"
          rm -f "$TEMP_KEY_FILE"
          exit 1
        fi

        # Validate token was extracted
        if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
          echo "::error::Token extraction failed - empty or null token"
          rm -f "$TEMP_KEY_FILE"
          exit 1
        fi

        # Clean up temp file
        echo "::debug::Cleaning up temporary key file..."
        rm -f "$TEMP_KEY_FILE"
        echo "::debug::Temporary file removed"

        # Mask token in logs for security (CRITICAL - must be done before using token)
        echo "::debug::Masking authentication token..."
        echo "::add-mask::$TOKEN"
        echo "::debug::Token masked successfully"

        # Set token as output for next step
        echo "token=$TOKEN" >> $GITHUB_OUTPUT
        echo "::debug::Token set as step output"

        echo "::endgroup::"
        echo "::notice::NewRelic authentication successful"

    - name: Build and Run
      id: run-action
      shell: bash
      env:
        INPUT_AGENT_TYPE: ${{ inputs.agent-type }}
        INPUT_VERSION: ${{ inputs.version }}
        NEWRELIC_TOKEN: ${{ steps.newrelic-auth.outputs.token }}
        APM_CONTROL_NR_LICENSE_KEY: ${{ inputs.apm-control-nr-license-key }}
      run: |
        set -e
        cd ${{ github.action_path }}
        # todo - look at using a built image instead
        go build -o agent-metadata-action ./cmd/agent-metadata-action
        ./agent-metadata-action
