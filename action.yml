name: 'Agent Metadata Action'
description: 'Fetches agent configuration metadata to create/update NEGP entities in NR'
inputs:
  newrelic-client-id:
    description: 'NewRelic client ID (pass from secrets)'
    required: true
  newrelic-private-key:
    description: 'NewRelic private key content (pass from secrets)'
    required: true
  agent-type:
    description: 'The type of agent eg. NRDotNetAgent'
    required: false
    default: ''
  version:
    description: 'Agent version tag name (ex. v1.2.3). Must match the exact git tag name for checkout.'
    required: false
    default: ''
  fetch-depth:
    description: 'Number of commits to fetch (> 1 may be required for docs flow)'
    required: false
    default: '1'
  oci-registry:
    description: 'OCI registry URL for binary uploads (e.g., ghcr.io/newrelic/agents). Leave empty to skip binary upload.'
    required: false
    default: ''
  oci-username:
    description: 'OCI registry username (required if oci-registry is set)'
    required: false
    default: ''
  oci-password:
    description: 'OCI registry password or token (required if oci-registry is set)'
    required: false
    default: ''
  binaries:
    description: 'JSON array with artifact definitions. Each artifact must specify name, path, os, arch, and format. Example: [{"name": "linux-tar", "path": "./dist/agent.tar.gz", "os": "linux", "arch": "amd64", "format": "tar+gzip"}]'
    required: false
    default: ''
  cache:
    description: 'Enable Go build cache'
    required: false
    default: 'true'
  apm-control-nr-license-key:
    description: 'New Relic APM license key for instrumentation of this action (optional, pass from secrets)'
    required: false
    default: ''
runs:
  using: 'composite'
  steps:
    - name: Set version ref for checkout
      id: version
      shell: bash
      run: |
        echo "ref=${{ inputs.version }}" >> $GITHUB_OUTPUT

    - name: Checkout repository
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        ref: ${{ steps.version.outputs.ref }} # When ref is empty (as in docs scenario), this will default to checking out the commit that triggered the action
        fetch-depth: ${{ inputs.fetch-depth }}
    - name: Setup Go
      uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
      with:
        go-version-file: '${{ github.action_path }}/go.mod'
        cache: ${{ inputs.cache }}
        cache-dependency-path: '${{ github.action_path }}/go.sum'

    - name: Install NewRelic Auth CLI
      shell: bash
      run: |
        # Only skip installation if explicitly testing with a mock CLI
        if [ "$MOCK_NEWRELIC_AUTH_CLI" = "true" ]; then
          if command -v newrelic-auth-cli &> /dev/null; then
            echo "::notice::Using mock newrelic-auth-cli from PATH (testing mode)"
            echo "::debug::Mock CLI at: $(which newrelic-auth-cli)"
            exit 0
          else
            echo "::error::MOCK_NEWRELIC_AUTH_CLI is true but newrelic-auth-cli not found in PATH"
            exit 1
          fi
        fi

        echo "::group::Installing newrelic-auth-cli"
        echo "Downloading newrelic-auth-cli"
        curl -L "https://github.com/newrelic/newrelic-auth-rs/releases/download/0.1.3/newrelic-auth-cli_amd64.tar.gz" -o newrelic-auth-cli.tar.gz
        tar -xzf newrelic-auth-cli.tar.gz
        chmod +x newrelic-auth-cli
        mkdir -p "$HOME/.local/bin"
        mv newrelic-auth-cli "$HOME/.local/bin/"
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        echo "::endgroup::"

    - name: Authenticate with NewRelic
      id: newrelic-auth
      shell: bash
      run: |
        set -e  # Exit on any error
        echo "::group::Authenticating with NewRelic"

        # Mask sensitive inputs in logs (must be done before any logging)
        echo "::debug::Masking sensitive credentials..."
        echo "::add-mask::${{ inputs.newrelic-client-id }}"
        echo "::add-mask::${{ inputs.newrelic-private-key }}"

        # Write private key to temporary file
        echo "::debug::Creating temporary file for private key..."
        TEMP_KEY_FILE=$(mktemp)
        echo "::debug::Temporary key file: $TEMP_KEY_FILE"

        echo "${{ inputs.newrelic-private-key }}" | base64 -d > "$TEMP_KEY_FILE"
        chmod 600 "$TEMP_KEY_FILE"
        echo "::debug::Private key written to temp file with secure permissions (600)"

        # Verify file was created
        if [ ! -f "$TEMP_KEY_FILE" ]; then
          echo "::error::Failed to create temporary key file"
          exit 1
        fi
        echo "::debug::Temp file verified (size: $(wc -c < "$TEMP_KEY_FILE") bytes)"

        # Authenticate and capture token
        echo "::debug::Calling newrelic-auth-cli..."
        echo "::debug::Environment: US"
        echo "::debug::Output format: JSON"

        if ! AUTH_OUTPUT=$(newrelic-auth-cli authenticate \
          --client-id "${{ inputs.newrelic-client-id }}" \
          --environment US \
          --output-token-format JSON \
          --private-key-path "$TEMP_KEY_FILE" 2>&1); then
          echo "::error::Authentication failed"
          rm -f "$TEMP_KEY_FILE"
          exit 1
        fi

        echo "::debug::Authentication CLI call completed"

        # Extract token from JSON output
        echo "::debug::Parsing JSON response..."
        if ! TOKEN=$(echo "$AUTH_OUTPUT" | jq -r '.access_token' 2>&1); then
          echo "::error::Failed to parse token from response"
          rm -f "$TEMP_KEY_FILE"
          exit 1
        fi

        # Validate token was extracted
        if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
          echo "::error::Token extraction failed - empty or null token"
          rm -f "$TEMP_KEY_FILE"
          exit 1
        fi

        # Clean up temp file
        echo "::debug::Cleaning up temporary key file..."
        rm -f "$TEMP_KEY_FILE"
        echo "::debug::Temporary file removed"

        # Mask token in logs for security (CRITICAL - must be done before using token)
        echo "::debug::Masking authentication token..."
        echo "::add-mask::$TOKEN"
        echo "::debug::Token masked successfully"

        # Set token as output for next step
        echo "token=$TOKEN" >> $GITHUB_OUTPUT
        echo "::debug::Token set as step output"

        echo "::endgroup::"
        echo "::notice::NewRelic authentication successful"

    - name: Build and Run
      id: run-action
      shell: bash
      env:
        INPUT_AGENT_TYPE: ${{ inputs.agent-type }}
        INPUT_VERSION: ${{ inputs.version }}
        NEWRELIC_TOKEN: ${{ steps.newrelic-auth.outputs.token }}
        INPUT_OCI_REGISTRY: ${{ inputs.oci-registry }}
        INPUT_OCI_USERNAME: ${{ inputs.oci-username }}
        INPUT_OCI_PASSWORD: ${{ inputs.oci-password }}
        INPUT_BINARIES: ${{ inputs.binaries }}
        APM_CONTROL_NR_LICENSE_KEY: ${{ inputs.apm-control-nr-license-key }}
      run: |
        set -e
        cd ${{ github.action_path }}
        # todo - look at using a built image instead
        go build -o agent-metadata-action ./cmd/agent-metadata-action
        ./agent-metadata-action
